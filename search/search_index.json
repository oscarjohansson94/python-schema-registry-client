{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Rest Client Schema Registry Python Rest Client to interact against schema-registry confluent server to manage Avro and JSON schemas resources. Requirements python 3.6+ Installation pip install python-schema-registry-client If you want the Faust functionality: pip install python-schema-registry-client [ faust ] Avro Schema Usage from schema_registry.client import SchemaRegistryClient , schema client = SchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) deployment_schema = { \"type\" : \"record\" , \"namespace\" : \"com.kubertenes\" , \"name\" : \"AvroDeployment\" , \"fields\" : [ { \"name\" : \"image\" , \"type\" : \"string\" }, { \"name\" : \"replicas\" , \"type\" : \"int\" }, { \"name\" : \"port\" , \"type\" : \"int\" }, ], } avro_schema = schema . AvroSchema ( deployment_schema ) schema_id = client . register ( \"test-deployment\" , avro_schema ) or async from schema_registry.client import AsyncSchemaRegistryClient , schema async_client = AsyncSchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) deployment_schema = { \"type\" : \"record\" , \"namespace\" : \"com.kubertenes\" , \"name\" : \"AvroDeployment\" , \"fields\" : [ { \"name\" : \"image\" , \"type\" : \"string\" }, { \"name\" : \"replicas\" , \"type\" : \"int\" }, { \"name\" : \"port\" , \"type\" : \"int\" }, ], } avro_schema = schema . AvroSchema ( deployment_schema ) schema_id = await async_client . register ( \"test-deployment\" , avro_schema ) JSON Schema Usage from schema_registry.client import SchemaRegistryClient , schema client = SchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) deployment_schema = { \"definitions\" : { \"JsonDeployment\" : { \"type\" : \"object\" , \"required\" : [ \"image\" , \"replicas\" , \"port\" ], \"properties\" : { \"image\" : { \"type\" : \"string\" }, \"replicas\" : { \"type\" : \"integer\" }, \"port\" : { \"type\" : \"integer\" } } } }, \"$ref\" : \"#/definitions/JsonDeployment\" } json_schema = schema . JsonSchema ( deployment_schema ) schema_id = client . register ( \"test-deployment\" , json_schema ) or async from schema_registry.client import AsyncSchemaRegistryClient , schema async_client = AsyncSchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) deployment_schema = { \"definitions\" : { \"JsonDeployment\" : { \"type\" : \"object\" , \"required\" : [ \"image\" , \"replicas\" , \"port\" ], \"properties\" : { \"image\" : { \"type\" : \"string\" }, \"replicas\" : { \"type\" : \"integer\" }, \"port\" : { \"type\" : \"integer\" } } } }, \"$ref\" : \"#/definitions/JsonDeployment\" } json_schema = schema . JsonSchema ( deployment_schema ) schema_id = await async_client . register ( \"test-deployment\" , json_schema ) Usage with dataclasses-avroschema for avro schemas You can generate the avro schema directely from a python class using dataclasses-avroschema and use it in the API for register schemas , check versions and test compatibility : import dataclasses from dataclasses_avroschema import AvroModel , types from schema_registry.client import SchemaRegistryClient client = SchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) @dataclasses . dataclass class UserAdvance ( AvroModel ): name : str age : int pets : typing . List [ str ] = dataclasses . field ( default_factory = lambda : [ \"dog\" , \"cat\" ]) accounts : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"key\" : 1 }) has_car : bool = False favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], default = \"BLUE\" ) country : str = \"Argentina\" address : str = None # register the schema schema_id = client . register ( subject , UserAdvance . avro_schema ()) print ( schema_id ) # >>> 12 result = client . check_version ( subject , UserAdvance . avro_schema ()) print ( result ) # >>> SchemaVersion(subject='dataclasses-avroschema-subject-2', schema_id=12, schema=1, version={\"type\":\"record\" ...') compatibility = client . test_compatibility ( subject , UserAdvance . avro_schema ()) print ( compatibility ) # >>> True Usage with pydantic for json schemas You can generate the json schema directely from a python class using pydantic and use it in the API for register schemas, check versions and test compatibility: import typing from enum import Enum from pydantic import BaseModel from schema_registry.client import SchemaRegistryClient client = SchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) class ColorEnum ( str , Enum ): BLUE = \"BLUE\" YELLOW = \"YELLOW\" GREEN = \"GREEN\" class UserAdvance ( BaseModel ): name : str age : int pets : typing . List [ str ] = [ \"dog\" , \"cat\" ] accounts : typing . Dict [ str , int ] = { \"key\" : 1 } has_car : bool = False favorite_colors : ColorEnum = ColorEnum . BLUE country : str = \"Argentina\" address : str = None # register the schema schema_id = client . register ( subject , UserAdvance . schema_json (), schema_type = \"JSON\" ) print ( schema_id ) # >>> 12 result = client . check_version ( subject , UserAdvance . schema_json (), schema_type = \"JSON\" ) print ( result ) # >>> SchemaVersion(subject='pydantic-jsonschema-subject', schema_id=12, schema=1, version=<schema_registry.client.schema.JsonSchema object at 0x7f40354550a0>) compatibility = client . test_compatibility ( subject , UserAdvance . schema_json (), schema_type = \"JSON\" ) print ( compatibility ) # >>> True When use this library Usually, we have a situacion like this: So, our producers/consumers have to serialize/deserialize messages every time that they send/receive from Kafka topics. In this picture, we can imagine a Faust application receiving messages (encoded with an Avro schema) and we want to deserialize them, so we can ask the schema server to do that for us. In this scenario, the MessageSerializer is perfect. Also, could be a use case that we would like to have an Application only to administrate Avro Schemas (register, update compatibilities, delete old schemas, etc.), so the SchemaRegistryClient is perfect. Development The tests are run against the Schema Server using docker compose , so you will need Docker and Docker Compose installed. ./scripts/test Run code linting: ./scripts/lint To perform tests using the python shell you can execute docker-compose up and the schema registry server will run on http://127.0.0.1:8081 , the you can interact against it using the SchemaRegistryClient : from schema_registry.client import SchemaRegistryClient , schema client = SchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) # do some operations with the client...","title":"Introduction"},{"location":"#python-rest-client-schema-registry","text":"Python Rest Client to interact against schema-registry confluent server to manage Avro and JSON schemas resources.","title":"Python Rest Client Schema Registry"},{"location":"#requirements","text":"python 3.6+","title":"Requirements"},{"location":"#installation","text":"pip install python-schema-registry-client If you want the Faust functionality: pip install python-schema-registry-client [ faust ]","title":"Installation"},{"location":"#avro-schema-usage","text":"from schema_registry.client import SchemaRegistryClient , schema client = SchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) deployment_schema = { \"type\" : \"record\" , \"namespace\" : \"com.kubertenes\" , \"name\" : \"AvroDeployment\" , \"fields\" : [ { \"name\" : \"image\" , \"type\" : \"string\" }, { \"name\" : \"replicas\" , \"type\" : \"int\" }, { \"name\" : \"port\" , \"type\" : \"int\" }, ], } avro_schema = schema . AvroSchema ( deployment_schema ) schema_id = client . register ( \"test-deployment\" , avro_schema ) or async from schema_registry.client import AsyncSchemaRegistryClient , schema async_client = AsyncSchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) deployment_schema = { \"type\" : \"record\" , \"namespace\" : \"com.kubertenes\" , \"name\" : \"AvroDeployment\" , \"fields\" : [ { \"name\" : \"image\" , \"type\" : \"string\" }, { \"name\" : \"replicas\" , \"type\" : \"int\" }, { \"name\" : \"port\" , \"type\" : \"int\" }, ], } avro_schema = schema . AvroSchema ( deployment_schema ) schema_id = await async_client . register ( \"test-deployment\" , avro_schema )","title":"Avro Schema Usage"},{"location":"#json-schema-usage","text":"from schema_registry.client import SchemaRegistryClient , schema client = SchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) deployment_schema = { \"definitions\" : { \"JsonDeployment\" : { \"type\" : \"object\" , \"required\" : [ \"image\" , \"replicas\" , \"port\" ], \"properties\" : { \"image\" : { \"type\" : \"string\" }, \"replicas\" : { \"type\" : \"integer\" }, \"port\" : { \"type\" : \"integer\" } } } }, \"$ref\" : \"#/definitions/JsonDeployment\" } json_schema = schema . JsonSchema ( deployment_schema ) schema_id = client . register ( \"test-deployment\" , json_schema ) or async from schema_registry.client import AsyncSchemaRegistryClient , schema async_client = AsyncSchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) deployment_schema = { \"definitions\" : { \"JsonDeployment\" : { \"type\" : \"object\" , \"required\" : [ \"image\" , \"replicas\" , \"port\" ], \"properties\" : { \"image\" : { \"type\" : \"string\" }, \"replicas\" : { \"type\" : \"integer\" }, \"port\" : { \"type\" : \"integer\" } } } }, \"$ref\" : \"#/definitions/JsonDeployment\" } json_schema = schema . JsonSchema ( deployment_schema ) schema_id = await async_client . register ( \"test-deployment\" , json_schema )","title":"JSON Schema Usage"},{"location":"#usage-with-dataclasses-avroschema-for-avro-schemas","text":"You can generate the avro schema directely from a python class using dataclasses-avroschema and use it in the API for register schemas , check versions and test compatibility : import dataclasses from dataclasses_avroschema import AvroModel , types from schema_registry.client import SchemaRegistryClient client = SchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) @dataclasses . dataclass class UserAdvance ( AvroModel ): name : str age : int pets : typing . List [ str ] = dataclasses . field ( default_factory = lambda : [ \"dog\" , \"cat\" ]) accounts : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"key\" : 1 }) has_car : bool = False favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], default = \"BLUE\" ) country : str = \"Argentina\" address : str = None # register the schema schema_id = client . register ( subject , UserAdvance . avro_schema ()) print ( schema_id ) # >>> 12 result = client . check_version ( subject , UserAdvance . avro_schema ()) print ( result ) # >>> SchemaVersion(subject='dataclasses-avroschema-subject-2', schema_id=12, schema=1, version={\"type\":\"record\" ...') compatibility = client . test_compatibility ( subject , UserAdvance . avro_schema ()) print ( compatibility ) # >>> True","title":"Usage with dataclasses-avroschema for avro schemas"},{"location":"#usage-with-pydantic-for-json-schemas","text":"You can generate the json schema directely from a python class using pydantic and use it in the API for register schemas, check versions and test compatibility: import typing from enum import Enum from pydantic import BaseModel from schema_registry.client import SchemaRegistryClient client = SchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) class ColorEnum ( str , Enum ): BLUE = \"BLUE\" YELLOW = \"YELLOW\" GREEN = \"GREEN\" class UserAdvance ( BaseModel ): name : str age : int pets : typing . List [ str ] = [ \"dog\" , \"cat\" ] accounts : typing . Dict [ str , int ] = { \"key\" : 1 } has_car : bool = False favorite_colors : ColorEnum = ColorEnum . BLUE country : str = \"Argentina\" address : str = None # register the schema schema_id = client . register ( subject , UserAdvance . schema_json (), schema_type = \"JSON\" ) print ( schema_id ) # >>> 12 result = client . check_version ( subject , UserAdvance . schema_json (), schema_type = \"JSON\" ) print ( result ) # >>> SchemaVersion(subject='pydantic-jsonschema-subject', schema_id=12, schema=1, version=<schema_registry.client.schema.JsonSchema object at 0x7f40354550a0>) compatibility = client . test_compatibility ( subject , UserAdvance . schema_json (), schema_type = \"JSON\" ) print ( compatibility ) # >>> True","title":"Usage with pydantic for json schemas"},{"location":"#when-use-this-library","text":"Usually, we have a situacion like this: So, our producers/consumers have to serialize/deserialize messages every time that they send/receive from Kafka topics. In this picture, we can imagine a Faust application receiving messages (encoded with an Avro schema) and we want to deserialize them, so we can ask the schema server to do that for us. In this scenario, the MessageSerializer is perfect. Also, could be a use case that we would like to have an Application only to administrate Avro Schemas (register, update compatibilities, delete old schemas, etc.), so the SchemaRegistryClient is perfect.","title":"When use this library"},{"location":"#development","text":"The tests are run against the Schema Server using docker compose , so you will need Docker and Docker Compose installed. ./scripts/test Run code linting: ./scripts/lint To perform tests using the python shell you can execute docker-compose up and the schema registry server will run on http://127.0.0.1:8081 , the you can interact against it using the SchemaRegistryClient : from schema_registry.client import SchemaRegistryClient , schema client = SchemaRegistryClient ( url = \"http://127.0.0.1:8081\" ) # do some operations with the client...","title":"Development"},{"location":"client/","text":"Client The Schema Registry Client consumes the API exposed by the schema-registry to operate resources that are avro and json schemas. You probably won't use this but is good to know that exists. The MessageSerializer is whom interact with the SchemaRegistryClient SchemaRegistryClient SchemaRegistryClient A client that talks to a Schema Registry over HTTP def __init__ ( self , url , ca_location = None , cert_location = None , key_location = None , key_password = None , extra_headers = None , timeout = httpx . _config . DEFAULT_TIMEOUT_CONFIG , pool_limits = httpx . _config . DEFAULT_POOL_LIMITS Args : url ( str | dict ) url : Url to schema registry or dictionary containing client configuration . ca_location ( str ): File or directory path to CA certificate ( s ) for verifying the Schema Registry key . cert_location ( str ): Path to public key used for authentication . key_location ( str ): Path to private key used for authentication . key_password ( str ): Key password extra_headers ( dict ): Extra headers to add on every requests . timeout ( httpx . _client . TimeoutTypes ): The timeout configuration to use when sending requests . pool_limits ( httpx . Limits ): The connection pool configuration to use when determining the maximum number of concurrently open HTTP connections . Methods Get Schema Get Schema for a given version. If version is None , try to resolve the latest schema def get_schema ( subject : str , version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> utils . SchemaVersion : \"\"\" Args: subject (str): subject name version (int, optional): version id. If is None, the latest schema is returned headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: utils.SchemaVersion (nametupled): (subject, schema_id, schema, version) None: If server returns a not success response: 404: Schema not found 422: Unprocessable entity ~ (200 - 299): Not success \"\"\" Get schema by id def get_by_id ( schema_id : int , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ]: \"\"\" Args: schema_id (int): Schema Id headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: typing.Union[client.schema.AvroSchema, client.schema.JsonSchema]: Avro or JSON Record schema \"\"\" Register a Schema def register ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ], headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]) -> int : \"\"\" Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: int: schema_id \"\"\" Get Subjects def get_subjects ( self , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" GET /subjects/(string: subject) Get list of all registered subjects in your Schema Registry. Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list [str]: list of registered subjects. \"\"\" Delete Schema def delete_subject ( subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list (int): versions of the schema deleted under this subject \"\"\" Check if a schema has already been registered under the specified subject def check_version ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ], headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]) -> dict : \"\"\" Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: dict: subject (string) -- Name of the subject that this schema is registered under id (int) -- Globally unique identifier of the schema version (int) -- Version of the returned schema schema (dict) -- The Avro or JSON schema None: If schema not found. \"\"\" Get schema version under a specific subject def get_versions ( self , subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" GET subjects/{subject}/versions Get a list of versions registered under the specified subject. Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list (str): version of the schema registered under this subject \"\"\" Deletes a specific version of the schema registered under a subject def delete_version ( self , subject : str , version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ): \"\"\" DELETE /subjects/(string: subject)/versions/(versionId: version) Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema. Args: subject (str): subject name version (str): Version of the schema to be deleted. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" deletes the last registered schema under the specified subject. headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: int: version of the schema deleted None: If the subject or version does not exist. \"\"\" Test Compatibility def test_compatibility ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ], version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]): \"\"\" By default the latest version is checked against. Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: bool: True if schema given compatible, False otherwise \"\"\" Get Compatibility def get_compatibility ( subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> str : \"\"\" Get the current compatibility level for a subject. Result will be one of: Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: str: one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE Raises: ClientError: if the request was unsuccessful or an invalid compatibility level was returned \"\"\" Update Compatibility def update_compatibility ( level : str , subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> bool : \"\"\" Update the compatibility level for a subject. If subject is None, the compatibility level is global. Args: level (str): one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: bool: True if compatibility was updated Raises: ClientError: if the request was unsuccessful or an invalid \"\"\" AsyncSchemaRegistryClient AsyncSchemaRegistryClient A client that talks to a Schema Registry over HTTP def __init__ ( self , url , ca_location = None , cert_location = None , key_location = None , extra_headers = None ) Args : url ( str | dict ) url : Url to schema registry or dictionary containing client configuration . ca_location ( str ): File or directory path to CA certificate ( s ) for verifying the Schema Registry key . cert_location ( str ): Path to public key used for authentication . key_location ( str ): Path to private key used for authentication . extra_headers ( dict ): Extra headers to add on every requests . Methods Get Schema Get Schema for a given version. If version is None , try to resolve the latest schema async def get_schema ( subject : str , version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> utils . SchemaVersion : \"\"\" Args: subject (str): subject name version (int, optional): version id. If is None, the latest schema is returned headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: utils.SchemaVersion (nametupled): (subject, schema_id, schema, version) None: If server returns a not success response: 404: Schema not found 422: Unprocessable entity ~ (200 - 299): Not success \"\"\" Get schema by id async def get_by_id ( schema_id : int , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ]: \"\"\" Args: schema_id (int): Schema Id headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: typing.Union[client.schema.AvroSchema, client.schema.JsonSchema]: Avro or JSON Record schema \"\"\" Register a Schema async def register ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ] headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]) -> int : \"\"\" Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: int: schema_id \"\"\" Get Subjects async def get_subjects ( self , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" GET /subjects/(string: subject) Get list of all registered subjects in your Schema Registry. Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list [str]: list of registered subjects. \"\"\" Delete Schema async def delete_subject ( subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list (int): versions of the schema deleted under this subject \"\"\" Check if a schema has already been registered under the specified subject async def check_version ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ], headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]) -> dict : \"\"\" Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: dict: subject (string) -- Name of the subject that this schema is registered under id (int) -- Globally unique identifier of the schema version (int) -- Version of the returned schema schema (dict) -- The Avro or JSON schema None: If schema not found. \"\"\" Get schema version under a specific subject async def get_versions ( self , subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" GET subjects/{subject}/versions Get a list of versions registered under the specified subject. Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list (str): version of the schema registered under this subject \"\"\" Deletes a specific version of the schema registered under a subject async def delete_version ( self , subject : str , version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ): \"\"\" DELETE /subjects/(string: subject)/versions/(versionId: version) Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema. Args: subject (str): subject name version (str): Version of the schema to be deleted. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" deletes the last registered schema under the specified subject. headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: int: version of the schema deleted None: If the subject or version does not exist. \"\"\" Test Compatibility async def test_compatibility ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ], version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]): \"\"\" By default the latest version is checked against. Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: bool: True if schema given compatible, False otherwise \"\"\" Get Compatibility async def get_compatibility ( subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> str : \"\"\" Get the current compatibility level for a subject. Result will be one of: Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: str: one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE Raises: ClientError: if the request was unsuccessful or an invalid compatibility level was returned \"\"\" Update Compatibility async def update_compatibility ( level : str , subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> bool : \"\"\" Update the compatibility level for a subject. If subject is None, the compatibility level is global. Args: level (str): one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: bool: True if compatibility was updated Raises: ClientError: if the request was unsuccessful or an invalid \"\"\"","title":"SchemaRegistryClient Api"},{"location":"client/#client","text":"The Schema Registry Client consumes the API exposed by the schema-registry to operate resources that are avro and json schemas. You probably won't use this but is good to know that exists. The MessageSerializer is whom interact with the SchemaRegistryClient","title":"Client"},{"location":"client/#schemaregistryclient","text":"SchemaRegistryClient A client that talks to a Schema Registry over HTTP def __init__ ( self , url , ca_location = None , cert_location = None , key_location = None , key_password = None , extra_headers = None , timeout = httpx . _config . DEFAULT_TIMEOUT_CONFIG , pool_limits = httpx . _config . DEFAULT_POOL_LIMITS Args : url ( str | dict ) url : Url to schema registry or dictionary containing client configuration . ca_location ( str ): File or directory path to CA certificate ( s ) for verifying the Schema Registry key . cert_location ( str ): Path to public key used for authentication . key_location ( str ): Path to private key used for authentication . key_password ( str ): Key password extra_headers ( dict ): Extra headers to add on every requests . timeout ( httpx . _client . TimeoutTypes ): The timeout configuration to use when sending requests . pool_limits ( httpx . Limits ): The connection pool configuration to use when determining the maximum number of concurrently open HTTP connections .","title":"SchemaRegistryClient"},{"location":"client/#methods","text":"","title":"Methods"},{"location":"client/#get-schema","text":"Get Schema for a given version. If version is None , try to resolve the latest schema def get_schema ( subject : str , version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> utils . SchemaVersion : \"\"\" Args: subject (str): subject name version (int, optional): version id. If is None, the latest schema is returned headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: utils.SchemaVersion (nametupled): (subject, schema_id, schema, version) None: If server returns a not success response: 404: Schema not found 422: Unprocessable entity ~ (200 - 299): Not success \"\"\"","title":"Get Schema"},{"location":"client/#get-schema-by-id","text":"def get_by_id ( schema_id : int , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ]: \"\"\" Args: schema_id (int): Schema Id headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: typing.Union[client.schema.AvroSchema, client.schema.JsonSchema]: Avro or JSON Record schema \"\"\"","title":"Get schema by id"},{"location":"client/#register-a-schema","text":"def register ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ], headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]) -> int : \"\"\" Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: int: schema_id \"\"\"","title":"Register a Schema"},{"location":"client/#get-subjects","text":"def get_subjects ( self , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" GET /subjects/(string: subject) Get list of all registered subjects in your Schema Registry. Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list [str]: list of registered subjects. \"\"\"","title":"Get Subjects"},{"location":"client/#delete-schema","text":"def delete_subject ( subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list (int): versions of the schema deleted under this subject \"\"\"","title":"Delete Schema"},{"location":"client/#check-if-a-schema-has-already-been-registered-under-the-specified-subject","text":"def check_version ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ], headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]) -> dict : \"\"\" Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: dict: subject (string) -- Name of the subject that this schema is registered under id (int) -- Globally unique identifier of the schema version (int) -- Version of the returned schema schema (dict) -- The Avro or JSON schema None: If schema not found. \"\"\"","title":"Check if a schema has already been registered under the specified subject"},{"location":"client/#get-schema-version-under-a-specific-subject","text":"def get_versions ( self , subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" GET subjects/{subject}/versions Get a list of versions registered under the specified subject. Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list (str): version of the schema registered under this subject \"\"\"","title":"Get schema version under a specific subject"},{"location":"client/#deletes-a-specific-version-of-the-schema-registered-under-a-subject","text":"def delete_version ( self , subject : str , version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ): \"\"\" DELETE /subjects/(string: subject)/versions/(versionId: version) Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema. Args: subject (str): subject name version (str): Version of the schema to be deleted. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" deletes the last registered schema under the specified subject. headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: int: version of the schema deleted None: If the subject or version does not exist. \"\"\"","title":"Deletes a specific version of the schema registered under a subject"},{"location":"client/#test-compatibility","text":"def test_compatibility ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ], version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]): \"\"\" By default the latest version is checked against. Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: bool: True if schema given compatible, False otherwise \"\"\"","title":"Test Compatibility"},{"location":"client/#get-compatibility","text":"def get_compatibility ( subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> str : \"\"\" Get the current compatibility level for a subject. Result will be one of: Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: str: one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE Raises: ClientError: if the request was unsuccessful or an invalid compatibility level was returned \"\"\"","title":"Get Compatibility"},{"location":"client/#update-compatibility","text":"def update_compatibility ( level : str , subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> bool : \"\"\" Update the compatibility level for a subject. If subject is None, the compatibility level is global. Args: level (str): one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: bool: True if compatibility was updated Raises: ClientError: if the request was unsuccessful or an invalid \"\"\"","title":"Update Compatibility"},{"location":"client/#asyncschemaregistryclient","text":"AsyncSchemaRegistryClient A client that talks to a Schema Registry over HTTP def __init__ ( self , url , ca_location = None , cert_location = None , key_location = None , extra_headers = None ) Args : url ( str | dict ) url : Url to schema registry or dictionary containing client configuration . ca_location ( str ): File or directory path to CA certificate ( s ) for verifying the Schema Registry key . cert_location ( str ): Path to public key used for authentication . key_location ( str ): Path to private key used for authentication . extra_headers ( dict ): Extra headers to add on every requests .","title":"AsyncSchemaRegistryClient"},{"location":"client/#methods_1","text":"","title":"Methods"},{"location":"client/#get-schema_1","text":"Get Schema for a given version. If version is None , try to resolve the latest schema async def get_schema ( subject : str , version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> utils . SchemaVersion : \"\"\" Args: subject (str): subject name version (int, optional): version id. If is None, the latest schema is returned headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: utils.SchemaVersion (nametupled): (subject, schema_id, schema, version) None: If server returns a not success response: 404: Schema not found 422: Unprocessable entity ~ (200 - 299): Not success \"\"\"","title":"Get Schema"},{"location":"client/#get-schema-by-id_1","text":"async def get_by_id ( schema_id : int , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ]: \"\"\" Args: schema_id (int): Schema Id headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: typing.Union[client.schema.AvroSchema, client.schema.JsonSchema]: Avro or JSON Record schema \"\"\"","title":"Get schema by id"},{"location":"client/#register-a-schema_1","text":"async def register ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ] headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]) -> int : \"\"\" Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: int: schema_id \"\"\"","title":"Register a Schema"},{"location":"client/#get-subjects_1","text":"async def get_subjects ( self , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" GET /subjects/(string: subject) Get list of all registered subjects in your Schema Registry. Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list [str]: list of registered subjects. \"\"\"","title":"Get Subjects"},{"location":"client/#delete-schema_1","text":"async def delete_subject ( subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list (int): versions of the schema deleted under this subject \"\"\"","title":"Delete Schema"},{"location":"client/#check-if-a-schema-has-already-been-registered-under-the-specified-subject_1","text":"async def check_version ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ], headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]) -> dict : \"\"\" Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: dict: subject (string) -- Name of the subject that this schema is registered under id (int) -- Globally unique identifier of the schema version (int) -- Version of the returned schema schema (dict) -- The Avro or JSON schema None: If schema not found. \"\"\"","title":"Check if a schema has already been registered under the specified subject"},{"location":"client/#get-schema-version-under-a-specific-subject_1","text":"async def get_versions ( self , subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> list : \"\"\" GET subjects/{subject}/versions Get a list of versions registered under the specified subject. Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: list (str): version of the schema registered under this subject \"\"\"","title":"Get schema version under a specific subject"},{"location":"client/#deletes-a-specific-version-of-the-schema-registered-under-a-subject_1","text":"async def delete_version ( self , subject : str , version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ): \"\"\" DELETE /subjects/(string: subject)/versions/(versionId: version) Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema. Args: subject (str): subject name version (str): Version of the schema to be deleted. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" deletes the last registered schema under the specified subject. headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: int: version of the schema deleted None: If the subject or version does not exist. \"\"\"","title":"Deletes a specific version of the schema registered under a subject"},{"location":"client/#test-compatibility_1","text":"async def test_compatibility ( subject : str , schema : typing . Union [ client . schema . AvroSchema , client . schema . JsonSchema ], version = \"latest\" , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT , schema_type : typing . Union [ \"AVRO\" , \"JSON\" ]): \"\"\" By default the latest version is checked against. Args: subject (str): subject name schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\" Returns: bool: True if schema given compatible, False otherwise \"\"\"","title":"Test Compatibility"},{"location":"client/#get-compatibility_1","text":"async def get_compatibility ( subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> str : \"\"\" Get the current compatibility level for a subject. Result will be one of: Args: subject (str): subject name headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: str: one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE Raises: ClientError: if the request was unsuccessful or an invalid compatibility level was returned \"\"\"","title":"Get Compatibility"},{"location":"client/#update-compatibility_1","text":"async def update_compatibility ( level : str , subject : str , headers : dict = None , timeout : typing . Union [ TimeoutTypes , UseClientDefault ] = USE_CLIENT_DEFAULT ) -> bool : \"\"\" Update the compatibility level for a subject. If subject is None, the compatibility level is global. Args: level (str): one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE headers (dict): Extra headers to add on the requests timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT Returns: bool: True if compatibility was updated Raises: ClientError: if the request was unsuccessful or an invalid \"\"\"","title":"Update Compatibility"},{"location":"exceptions/","text":"ClientError An instance of ClientError is returned when an error occurs. class ClientError ( Exception ): \"\"\" Error thrown by Schema Registry clients \"\"\" def __init__ ( self , message , http_code = None , server_traceback = None ): self . message = message self . server_traceback = server_traceback self . http_code = http_code super ( ClientError , self ) . __init__ ( self . __str__ ()) def __repr__ ( self ): return f \"ClientError(error= { self . message } )\" def __str__ ( self ): return self . message For example: try : # Try to get the compatibility level of a subject that does not exist # The Schema Registry Server returns 404 compatibility = client . get_compatibility ( \"subject-does-not-exists\" ) except Exception as error : # Print 404 print ( error . http_code )","title":"Exceptions"},{"location":"exceptions/#clienterror","text":"An instance of ClientError is returned when an error occurs. class ClientError ( Exception ): \"\"\" Error thrown by Schema Registry clients \"\"\" def __init__ ( self , message , http_code = None , server_traceback = None ): self . message = message self . server_traceback = server_traceback self . http_code = http_code super ( ClientError , self ) . __init__ ( self . __str__ ()) def __repr__ ( self ): return f \"ClientError(error= { self . message } )\" def __str__ ( self ): return self . message For example: try : # Try to get the compatibility level of a subject that does not exist # The Schema Registry Server returns 404 compatibility = client . get_compatibility ( \"subject-does-not-exists\" ) except Exception as error : # Print 404 print ( error . http_code )","title":"ClientError"},{"location":"faust/","text":"How to use it with Faust This section describe how integrate this library with Faust Schemas, Custom Codecs and Serializers Because we want to be sure that the message that we encode are valid, we can use Avro or JSON schemas. Also, Introduction to Schemas in Apache Kafka with the Confluent Schema Registry is a good post to start with schemas . Avro and JSON can be used to define the data schema for a record's value. This schema describes the fields allowed in the value, along with their data types. In order to use avro schemas or json schemas with Faust , we need to define a custom codec and a custom serializer able to talk with the schema-registry , and to do that, we will use the MessageSerializer . For serializing avro schemas we should use the FaustSerializer . For serializing json schemas we should use the FaustJsonSerializer . For our demonstration, let's imagine that we have the following avro schema : { \"type\" : \"record\" , \"namespace\" : \"com.example\" , \"name\" : \"AvroUsers\" , \"fields\" : [ { \"name\" : \"first_name\" , \"type\" : \"string\" }, { \"name\" : \"last_name\" , \"type\" : \"string\" } ] } Let's register the custom codec # codecs.codec.py from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers.faust import FaustSerializer # create an instance of the `SchemaRegistryClient` client = SchemaRegistryClient ( url = settings . SCHEMA_REGISTRY_URL ) # schema that we want to use. For this example we # are using a dict, but this schema could be located in a file called avro_user_schema.avsc avro_user_schema = schema . AvroSchema ({ \"type\" : \"record\" , \"namespace\" : \"com.example\" , \"name\" : \"AvroUsers\" , \"fields\" : [ { \"name\" : \"first_name\" , \"type\" : \"string\" }, { \"name\" : \"last_name\" , \"type\" : \"string\" } ] }) avro_user_serializer = FaustSerializer ( client , \"users\" , avro_user_schema ) # function used to register the codec def avro_user_codec (): return avro_user_serializer and ddd in setup.py the folloing code in order to tell faust where to find the custom codecs. # setup.py setup ( ... entry_points = { 'console_scripts' : [ 'example = example.app:main' , ], 'faust.codecs' : [ 'avro_users = example.codecs.avro:avro_user_codec' , ], }, ) Now the final step is to integrate the faust model with the AvroSerializer. # users.models import faust class UserModel ( faust . Record , serializer = 'avro_users' ): first_name : str last_name : str Now our application is able to send and receive message using arvo schemas!!!! :-) import logging from your_project.app import app from .codecs.codec import avro_user_serializer from .models import UserModel users_topic = app . topic ( 'avro_users' , partitions = 1 , value_type = UserModel ) logger = logging . getLogger ( __name__ ) @app . agent ( users_topic ) async def users ( users ): async for user in users : logger . info ( \"Event received in topic avro_users\" ) logger . info ( f \"First Name: { user . first_name } , last name { user . last_name } \" ) @app . timer ( 5.0 , on_leader = True ) async def publish_users (): logger . info ( 'PUBLISHING ON LEADER FOR USERS APP!' ) user = { \"first_name\" : \"foo\" , \"last_name\" : \"bar\" } await users . send ( value = user , value_serializer = avro_user_serializer ) The full example is here Usage with dataclasses-avroschema for avro schemas You can also use this funcionality with dataclasses-avroschema and you won't have to provide the avro schema. The only thing that you need to do is add the AvroModel class and use its methods: # users.models import faust from dataclasses_avroschema import AvroModel class UserModel ( faust . Record , AvroModel , serializer = 'avro_users' ): first_name : str last_name : str # codecs.codec.py from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers.faust import FaustSerializer from users.models import UserModel # create an instance of the `SchemaRegistryClient` client = SchemaRegistryClient ( url = settings . SCHEMA_REGISTRY_URL ) avro_user_serializer = FaustSerializer ( client , \"users\" , UserModel . avro_schema ()) # usign the method avro_schema to get the avro schema representation # function used to register the codec def avro_user_codec (): return avro_user_serializer Usage with pydantic for json schemas You can also use this funcionality with dataclasses-pydantic and you won't have to provide the json schema. The only thing that you need to do is add the BaseModel class and use its methods: # users.models import faust from pydantic import BaseModel class UserModel ( faust . Record , BaseModel , serializer = 'json_users' ): first_name : str last_name : str # codecs.codec.py from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers.faust import FaustJsonSerializer from users.models import UserModel # create an instance of the `SchemaRegistryClient` client = SchemaRegistryClient ( url = settings . SCHEMA_REGISTRY_URL ) json_user_serializer = FaustJsonSerializer ( client , \"users\" , UserModel . schema_json ()) # usign the method schema_json to get the json schema representation # function used to register the codec def json_user_codec (): return json_user_serializer","title":"Faust integration"},{"location":"faust/#how-to-use-it-with-faust","text":"This section describe how integrate this library with Faust","title":"How to use it with Faust"},{"location":"faust/#schemas-custom-codecs-and-serializers","text":"Because we want to be sure that the message that we encode are valid, we can use Avro or JSON schemas. Also, Introduction to Schemas in Apache Kafka with the Confluent Schema Registry is a good post to start with schemas . Avro and JSON can be used to define the data schema for a record's value. This schema describes the fields allowed in the value, along with their data types. In order to use avro schemas or json schemas with Faust , we need to define a custom codec and a custom serializer able to talk with the schema-registry , and to do that, we will use the MessageSerializer . For serializing avro schemas we should use the FaustSerializer . For serializing json schemas we should use the FaustJsonSerializer . For our demonstration, let's imagine that we have the following avro schema : { \"type\" : \"record\" , \"namespace\" : \"com.example\" , \"name\" : \"AvroUsers\" , \"fields\" : [ { \"name\" : \"first_name\" , \"type\" : \"string\" }, { \"name\" : \"last_name\" , \"type\" : \"string\" } ] } Let's register the custom codec # codecs.codec.py from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers.faust import FaustSerializer # create an instance of the `SchemaRegistryClient` client = SchemaRegistryClient ( url = settings . SCHEMA_REGISTRY_URL ) # schema that we want to use. For this example we # are using a dict, but this schema could be located in a file called avro_user_schema.avsc avro_user_schema = schema . AvroSchema ({ \"type\" : \"record\" , \"namespace\" : \"com.example\" , \"name\" : \"AvroUsers\" , \"fields\" : [ { \"name\" : \"first_name\" , \"type\" : \"string\" }, { \"name\" : \"last_name\" , \"type\" : \"string\" } ] }) avro_user_serializer = FaustSerializer ( client , \"users\" , avro_user_schema ) # function used to register the codec def avro_user_codec (): return avro_user_serializer and ddd in setup.py the folloing code in order to tell faust where to find the custom codecs. # setup.py setup ( ... entry_points = { 'console_scripts' : [ 'example = example.app:main' , ], 'faust.codecs' : [ 'avro_users = example.codecs.avro:avro_user_codec' , ], }, ) Now the final step is to integrate the faust model with the AvroSerializer. # users.models import faust class UserModel ( faust . Record , serializer = 'avro_users' ): first_name : str last_name : str Now our application is able to send and receive message using arvo schemas!!!! :-) import logging from your_project.app import app from .codecs.codec import avro_user_serializer from .models import UserModel users_topic = app . topic ( 'avro_users' , partitions = 1 , value_type = UserModel ) logger = logging . getLogger ( __name__ ) @app . agent ( users_topic ) async def users ( users ): async for user in users : logger . info ( \"Event received in topic avro_users\" ) logger . info ( f \"First Name: { user . first_name } , last name { user . last_name } \" ) @app . timer ( 5.0 , on_leader = True ) async def publish_users (): logger . info ( 'PUBLISHING ON LEADER FOR USERS APP!' ) user = { \"first_name\" : \"foo\" , \"last_name\" : \"bar\" } await users . send ( value = user , value_serializer = avro_user_serializer ) The full example is here","title":"Schemas, Custom Codecs and Serializers"},{"location":"faust/#usage-with-dataclasses-avroschema-for-avro-schemas","text":"You can also use this funcionality with dataclasses-avroschema and you won't have to provide the avro schema. The only thing that you need to do is add the AvroModel class and use its methods: # users.models import faust from dataclasses_avroschema import AvroModel class UserModel ( faust . Record , AvroModel , serializer = 'avro_users' ): first_name : str last_name : str # codecs.codec.py from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers.faust import FaustSerializer from users.models import UserModel # create an instance of the `SchemaRegistryClient` client = SchemaRegistryClient ( url = settings . SCHEMA_REGISTRY_URL ) avro_user_serializer = FaustSerializer ( client , \"users\" , UserModel . avro_schema ()) # usign the method avro_schema to get the avro schema representation # function used to register the codec def avro_user_codec (): return avro_user_serializer","title":"Usage with dataclasses-avroschema for avro schemas"},{"location":"faust/#usage-with-pydantic-for-json-schemas","text":"You can also use this funcionality with dataclasses-pydantic and you won't have to provide the json schema. The only thing that you need to do is add the BaseModel class and use its methods: # users.models import faust from pydantic import BaseModel class UserModel ( faust . Record , BaseModel , serializer = 'json_users' ): first_name : str last_name : str # codecs.codec.py from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers.faust import FaustJsonSerializer from users.models import UserModel # create an instance of the `SchemaRegistryClient` client = SchemaRegistryClient ( url = settings . SCHEMA_REGISTRY_URL ) json_user_serializer = FaustJsonSerializer ( client , \"users\" , UserModel . schema_json ()) # usign the method schema_json to get the json schema representation # function used to register the codec def json_user_codec (): return json_user_serializer","title":"Usage with pydantic for json schemas"},{"location":"schemaregistry_server/","text":"Schema Registry Server This section provides you just an introduction about the Schema Server . Schema Registry provides a serving layer for your metadata. It provides a RESTful interface for storing and retrieving Avro or JSON schemas. It stores a versioned history of all schemas, provides multiple compatibility settings and allows evolution of schemas according to the configured compatibility settings and expanded Avro or JSON support. It provides serializers that plug into Apache Kafka\u00ae clients that handle schema storage and retrieval for Kafka messages that are sent in the Avro or JSON format. Schema Registry is a distributed storage layer for Avro or JSON Schemas which uses Kafka as its underlying storage mechanism. Some key design decisions: Assigns globally unique ID to each registered schema. Allocated IDs are guaranteed to be monotonically increasing but not necessarily consecutive. Kafka provides the durable backend, and functions as a write-ahead changelog for the state of Schema Registry and the schemas it contains. Schema Registry is designed to be distributed, with single-primary architecture, and ZooKeeper/Kafka coordinates primary election (based on the configuration). API Schemas GET /schemas/ids/{int: id} - Get the schema string identified by the input ID Subjects GET /subjects - Get a list of registered subjects. [Missing] GET /subjects/(string: subject)/versions - Get a list of versions registered under the specified subject [Missing] DELETE /subjects/(string: subject) - Deletes the specified subject and its associated compatibility level if registered. It is recommended to use this API only when a topic needs to be recycled or in development environment. GET /subjects/(string: subject)/versions/(versionId: version) - Get a specific version of the schema registered under this subject Check response GET /subjects/(string: subject)/versions/(versionId: version)/schema - Get the avro or json schema for the specified version of this subject. The unescaped schema only is returned. [Missing] POST /subjects/(string: subject)/versions - Register a new schema under the specified subject and receive a schema id POST /subjects/(string: subject) - Check if a schema has already been registered under the specified subject. If so, this returns the schema string along with its globally unique identifier, its version under this subject and the subject name. DELETE /subjects/(string: subject)/versions/(versionId: version) - Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema. [Missing] Compatibility POST /compatibility/subjects/(string: subject)/versions/(versionId: version) - Test input schema against a particular version of a subject's schema for compatibility. Note that the compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config). These are the compatibility types: BACKWARD : (default) consumers using the new schema can read data written by producers using the latest registered schema BACKWARD_TRANSITIVE : consumers using the new schema can read data written by producers using all previously registered schemas FORWARD : consumers using the latest registered schema can read data written by producers using the new schema FORWARD_TRANSITIVE : consumers using all previously registered schemas can read data written by producers using the new schema FULL : the new schema is forward and backward compatible with the latest registered schema FULL_TRANSITIVE : the new schema is forward and backward compatible with all previously registered schemas NONE : schema compatibility checks are disabled Config GET /config - Get global compatibility level. PUT /config - Update global compatibility level. [Missing] GET /config/(string: subject) - Get compatibility level for a subject. [Missing] PUT /config/(string: subject) - Update compatibility level for the specified subject. Too know more about the API go here","title":"Schema Registry Server"},{"location":"schemaregistry_server/#schema-registry-server","text":"This section provides you just an introduction about the Schema Server . Schema Registry provides a serving layer for your metadata. It provides a RESTful interface for storing and retrieving Avro or JSON schemas. It stores a versioned history of all schemas, provides multiple compatibility settings and allows evolution of schemas according to the configured compatibility settings and expanded Avro or JSON support. It provides serializers that plug into Apache Kafka\u00ae clients that handle schema storage and retrieval for Kafka messages that are sent in the Avro or JSON format. Schema Registry is a distributed storage layer for Avro or JSON Schemas which uses Kafka as its underlying storage mechanism. Some key design decisions: Assigns globally unique ID to each registered schema. Allocated IDs are guaranteed to be monotonically increasing but not necessarily consecutive. Kafka provides the durable backend, and functions as a write-ahead changelog for the state of Schema Registry and the schemas it contains. Schema Registry is designed to be distributed, with single-primary architecture, and ZooKeeper/Kafka coordinates primary election (based on the configuration).","title":"Schema Registry Server"},{"location":"schemaregistry_server/#api","text":"","title":"API"},{"location":"schemaregistry_server/#schemas","text":"GET /schemas/ids/{int: id} - Get the schema string identified by the input ID","title":"Schemas"},{"location":"schemaregistry_server/#subjects","text":"GET /subjects - Get a list of registered subjects. [Missing] GET /subjects/(string: subject)/versions - Get a list of versions registered under the specified subject [Missing] DELETE /subjects/(string: subject) - Deletes the specified subject and its associated compatibility level if registered. It is recommended to use this API only when a topic needs to be recycled or in development environment. GET /subjects/(string: subject)/versions/(versionId: version) - Get a specific version of the schema registered under this subject Check response GET /subjects/(string: subject)/versions/(versionId: version)/schema - Get the avro or json schema for the specified version of this subject. The unescaped schema only is returned. [Missing] POST /subjects/(string: subject)/versions - Register a new schema under the specified subject and receive a schema id POST /subjects/(string: subject) - Check if a schema has already been registered under the specified subject. If so, this returns the schema string along with its globally unique identifier, its version under this subject and the subject name. DELETE /subjects/(string: subject)/versions/(versionId: version) - Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema. [Missing]","title":"Subjects"},{"location":"schemaregistry_server/#compatibility","text":"POST /compatibility/subjects/(string: subject)/versions/(versionId: version) - Test input schema against a particular version of a subject's schema for compatibility. Note that the compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config). These are the compatibility types: BACKWARD : (default) consumers using the new schema can read data written by producers using the latest registered schema BACKWARD_TRANSITIVE : consumers using the new schema can read data written by producers using all previously registered schemas FORWARD : consumers using the latest registered schema can read data written by producers using the new schema FORWARD_TRANSITIVE : consumers using all previously registered schemas can read data written by producers using the new schema FULL : the new schema is forward and backward compatible with the latest registered schema FULL_TRANSITIVE : the new schema is forward and backward compatible with all previously registered schemas NONE : schema compatibility checks are disabled","title":"Compatibility"},{"location":"schemaregistry_server/#config","text":"GET /config - Get global compatibility level. PUT /config - Update global compatibility level. [Missing] GET /config/(string: subject) - Get compatibility level for a subject. [Missing] PUT /config/(string: subject) - Update compatibility level for the specified subject. Too know more about the API go here","title":"Config"},{"location":"schemas/","text":"Schemas BaseSchema BaseSchema an abstract base class from which AvroSchema and JsonSchema inherit. Requires concrete classes implement the following methods. @abstractmethod def parse_schema ( self , schema : typing . Dict ) -> typing . Dict : pass @staticmethod @abstractmethod def load ( fp : str ) -> BaseSchema : \"\"\"Parse a schema from a file path\"\"\" pass @staticmethod @abstractmethod async def async_load ( fp : str ) -> BaseSchema : \"\"\"Parse a schema from a file path\"\"\" pass @property @abstractmethod def name ( self ) -> typing . Optional [ str ]: pass @property @abstractmethod def schema_type ( self ) -> str : pass AvroSchema AvroSchema parses strings into avro schemas to assure validation. Properties: raw_schema : The input string that will be parsed schema : Result of parsing the raw_schema with fastavro flat_schema : Parsed schema without __fastavro_parsed flag expanded_schema : Parsed schema where all named types are expanded to their real schema JsonSchema JsonSchema parses strings into json schemas to assure validation. Properties: raw_schema : The input string that will be parsed schema : Result of parsing the raw_schema with jsonschema.Draft7Validator.check_schema SchemaVersion SchemaVersion is a namedtuple that contains the subject , schema_id , version and either AvroSchema or JsonSchema . The SchemaVersion is returned by get_schema and check_version client methods","title":"Schemas"},{"location":"schemas/#schemas","text":"","title":"Schemas"},{"location":"schemas/#baseschema","text":"BaseSchema an abstract base class from which AvroSchema and JsonSchema inherit. Requires concrete classes implement the following methods. @abstractmethod def parse_schema ( self , schema : typing . Dict ) -> typing . Dict : pass @staticmethod @abstractmethod def load ( fp : str ) -> BaseSchema : \"\"\"Parse a schema from a file path\"\"\" pass @staticmethod @abstractmethod async def async_load ( fp : str ) -> BaseSchema : \"\"\"Parse a schema from a file path\"\"\" pass @property @abstractmethod def name ( self ) -> typing . Optional [ str ]: pass @property @abstractmethod def schema_type ( self ) -> str : pass","title":"BaseSchema"},{"location":"schemas/#avroschema","text":"AvroSchema parses strings into avro schemas to assure validation. Properties: raw_schema : The input string that will be parsed schema : Result of parsing the raw_schema with fastavro flat_schema : Parsed schema without __fastavro_parsed flag expanded_schema : Parsed schema where all named types are expanded to their real schema","title":"AvroSchema"},{"location":"schemas/#jsonschema","text":"JsonSchema parses strings into json schemas to assure validation. Properties: raw_schema : The input string that will be parsed schema : Result of parsing the raw_schema with jsonschema.Draft7Validator.check_schema","title":"JsonSchema"},{"location":"schemas/#schemaversion","text":"SchemaVersion is a namedtuple that contains the subject , schema_id , version and either AvroSchema or JsonSchema . The SchemaVersion is returned by get_schema and check_version client methods","title":"SchemaVersion"},{"location":"serializer/","text":"Message Serializers To serialize and deserialize messages you can use AvroMessageSerializer and JsonMessageSerializer . They interact with the SchemaRegistryClient to get avro Schemas and json schemas in order to process messages. If you want to run the following examples run docker-compose up and the schema registry server will run on http://127.0.0.1:8081 Usage for avro schemas from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers import AvroMessageSerializer client = SchemaRegistryClient ( \"http://127.0.0.1:8081\" ) avro_message_serializer = AvroMessageSerializer ( client ) avro_user_schema = schema . AvroSchema ({ \"type\" : \"record\" , \"namespace\" : \"com.example\" , \"name\" : \"AvroUsers\" , \"fields\" : [ { \"name\" : \"first_name\" , \"type\" : \"string\" }, { \"name\" : \"last_name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, ], }) # We want to encode the user_record with avro_user_schema user_record = { \"first_name\" : \"my_first_name\" , \"last_name\" : \"my_last_name\" , \"age\" : 20 , } # Encode the record message_encoded = avro_message_serializer . encode_record_with_schema ( \"user\" , avro_user_schema , user_record ) # this is because the message encoded reserved 5 bytes for the schema_id assert len ( message_encoded ) > 5 assert isinstance ( message_encoded , bytes ) # Decode the message message_decoded = avro_message_serializer . decode_message ( message_encoded ) assert message_decoded == user_record # Now if we send a bad record bad_record = { \"first_name\" : \"my_first_name\" , \"last_name\" : \"my_last_name\" , \"age\" : \"my_age\" } avro_message_serializer . encode_record_with_schema ( \"user\" , avro_user_schema , bad_record ) # >>> TypeError: an integer is required on field age (This script is complete, it should run \"as is\") Usage for json schemas from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers import JsonMessageSerializer client = SchemaRegistryClient ( \"http://127.0.0.1:8081\" ) json_message_serializer = JsonMessageSerializer ( client ) json_schema = schema . JsonSchema ({ \"definitions\" : { \"record:python.test.basic.basic\" : { \"description\" : \"basic schema for tests\" , \"type\" : \"object\" , \"required\" : [ \"number\" , \"name\" ], \"properties\" : { \"number\" : { \"oneOf\" : [ { \"type\" : \"integer\" }, { \"type\" : \"null\" } ] }, \"name\" : { \"oneOf\" : [ { \"type\" : \"string\" } ] } } } }, \"$ref\" : \"#/definitions/record:python.test.basic.basic\" }) # Encode the record basic_record = { \"number\" : 10 , \"name\" : \"a_name\" , } message_encoded = json_message_serializer . encode_record_with_schema ( \"basic\" , json_schema , basic_record ) # this is because the message encoded reserved 5 bytes for the schema_id assert len ( message_encoded ) > 5 assert isinstance ( message_encoded , bytes ) # Decode the message message_decoded = json_message_serializer . decode_message ( message_encoded ) assert message_decoded == basic_record (This script is complete, it should run \"as is\") Async implementations Please note that JsonMessageSerializer , AvroMessageSerializer and SchemaRegistryClient have their asynchronous counterparts AsyncJsonMessageSerializer , AsyncAvroMessageSerializer and AsyncSchemaRegistryClient and all examples above should work if you replace them with their async variations Classes and Methods AvroMessageSerializer Args: schemaregistry_client ( schema_registry . client . SchemaRegistryClient ) : Http Client JsonMessageSerializer Args: schemaregistry_client ( schema_registry . client . SchemaRegistryClient ) : Http Client AsyncAvroMessageSerializer Args: schemaregistry_client ( schema_registry . client . AsyncSchemaRegistryClient ) : Http Client AsyncJsonMessageSerializer Args: schemaregistry_client ( schema_registry . client . AsyncSchemaRegistryClient ) : Http Client Encode record with a Schema def encode_record_with_schema ( subject , schema , record ): \"\"\" Args: subject (str): Subject name schema (avro.schema.RecordSchema): Avro Schema record (dict): An object to serialize Returns: bytes: Encoded record with schema ID as bytes \"\"\" Encode a record with a schema id def encode_record_with_schema_id ( schema_id , record ): \"\"\" Args: schema_id (int): integer ID record (dict): An object to serialize Returns: func: decoder function \"\"\" Decode a message encoded previously def decode_message ( message ): \"\"\" Args: message (str|bytes or None): message key or value to be decoded Returns: dict: Decoded message contents. \"\"\"","title":"Message Serializer"},{"location":"serializer/#message-serializers","text":"To serialize and deserialize messages you can use AvroMessageSerializer and JsonMessageSerializer . They interact with the SchemaRegistryClient to get avro Schemas and json schemas in order to process messages. If you want to run the following examples run docker-compose up and the schema registry server will run on http://127.0.0.1:8081","title":"Message Serializers"},{"location":"serializer/#usage-for-avro-schemas","text":"from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers import AvroMessageSerializer client = SchemaRegistryClient ( \"http://127.0.0.1:8081\" ) avro_message_serializer = AvroMessageSerializer ( client ) avro_user_schema = schema . AvroSchema ({ \"type\" : \"record\" , \"namespace\" : \"com.example\" , \"name\" : \"AvroUsers\" , \"fields\" : [ { \"name\" : \"first_name\" , \"type\" : \"string\" }, { \"name\" : \"last_name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, ], }) # We want to encode the user_record with avro_user_schema user_record = { \"first_name\" : \"my_first_name\" , \"last_name\" : \"my_last_name\" , \"age\" : 20 , } # Encode the record message_encoded = avro_message_serializer . encode_record_with_schema ( \"user\" , avro_user_schema , user_record ) # this is because the message encoded reserved 5 bytes for the schema_id assert len ( message_encoded ) > 5 assert isinstance ( message_encoded , bytes ) # Decode the message message_decoded = avro_message_serializer . decode_message ( message_encoded ) assert message_decoded == user_record # Now if we send a bad record bad_record = { \"first_name\" : \"my_first_name\" , \"last_name\" : \"my_last_name\" , \"age\" : \"my_age\" } avro_message_serializer . encode_record_with_schema ( \"user\" , avro_user_schema , bad_record ) # >>> TypeError: an integer is required on field age (This script is complete, it should run \"as is\")","title":"Usage for avro schemas"},{"location":"serializer/#usage-for-json-schemas","text":"from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers import JsonMessageSerializer client = SchemaRegistryClient ( \"http://127.0.0.1:8081\" ) json_message_serializer = JsonMessageSerializer ( client ) json_schema = schema . JsonSchema ({ \"definitions\" : { \"record:python.test.basic.basic\" : { \"description\" : \"basic schema for tests\" , \"type\" : \"object\" , \"required\" : [ \"number\" , \"name\" ], \"properties\" : { \"number\" : { \"oneOf\" : [ { \"type\" : \"integer\" }, { \"type\" : \"null\" } ] }, \"name\" : { \"oneOf\" : [ { \"type\" : \"string\" } ] } } } }, \"$ref\" : \"#/definitions/record:python.test.basic.basic\" }) # Encode the record basic_record = { \"number\" : 10 , \"name\" : \"a_name\" , } message_encoded = json_message_serializer . encode_record_with_schema ( \"basic\" , json_schema , basic_record ) # this is because the message encoded reserved 5 bytes for the schema_id assert len ( message_encoded ) > 5 assert isinstance ( message_encoded , bytes ) # Decode the message message_decoded = json_message_serializer . decode_message ( message_encoded ) assert message_decoded == basic_record (This script is complete, it should run \"as is\")","title":"Usage for json schemas"},{"location":"serializer/#async-implementations","text":"Please note that JsonMessageSerializer , AvroMessageSerializer and SchemaRegistryClient have their asynchronous counterparts AsyncJsonMessageSerializer , AsyncAvroMessageSerializer and AsyncSchemaRegistryClient and all examples above should work if you replace them with their async variations","title":"Async implementations"},{"location":"serializer/#classes-and-methods","text":"AvroMessageSerializer Args: schemaregistry_client ( schema_registry . client . SchemaRegistryClient ) : Http Client JsonMessageSerializer Args: schemaregistry_client ( schema_registry . client . SchemaRegistryClient ) : Http Client AsyncAvroMessageSerializer Args: schemaregistry_client ( schema_registry . client . AsyncSchemaRegistryClient ) : Http Client AsyncJsonMessageSerializer Args: schemaregistry_client ( schema_registry . client . AsyncSchemaRegistryClient ) : Http Client","title":"Classes and Methods"},{"location":"serializer/#encode-record-with-a-schema","text":"def encode_record_with_schema ( subject , schema , record ): \"\"\" Args: subject (str): Subject name schema (avro.schema.RecordSchema): Avro Schema record (dict): An object to serialize Returns: bytes: Encoded record with schema ID as bytes \"\"\"","title":"Encode record with a Schema"},{"location":"serializer/#encode-a-record-with-a-schema-id","text":"def encode_record_with_schema_id ( schema_id , record ): \"\"\" Args: schema_id (int): integer ID record (dict): An object to serialize Returns: func: decoder function \"\"\"","title":"Encode a record with a schema id"},{"location":"serializer/#decode-a-message-encoded-previously","text":"def decode_message ( message ): \"\"\" Args: message (str|bytes or None): message key or value to be decoded Returns: dict: Decoded message contents. \"\"\"","title":"Decode a message encoded previously"}]}